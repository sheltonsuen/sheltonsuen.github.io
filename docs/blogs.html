<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-03563fcad3d02ed9.js" defer=""></script><script src="/_next/static/chunks/framework-9c6699f00da9ef7f.js" defer=""></script><script src="/_next/static/chunks/main-f7f281abfe54e061.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5913ad26284716e6.js" defer=""></script><script src="/_next/static/chunks/pages/blogs-ddf51bb6834bfcda.js" defer=""></script><script src="/_next/static/hTW_bqqKBeJGxFspWEgyj/_buildManifest.js" defer=""></script><script src="/_next/static/hTW_bqqKBeJGxFspWEgyj/_ssgManifest.js" defer=""></script><script src="/_next/static/hTW_bqqKBeJGxFspWEgyj/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">body{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
#__next{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}/*!sc*/
data-styled.g1[id="sc-global-ejORCz1"]{content:"sc-global-ejORCz1,"}/*!sc*/
.cRaYml{width:100%;height:100%;vertical-align:middle;border-radius:50%;}/*!sc*/
data-styled.g2[id="Avatar__Img-sc-j2rhp9-0"]{content:"cRaYml,"}/*!sc*/
.itjVmX{padding:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;list-style:none;border-bottom:1px solid #cacfd2;}/*!sc*/
data-styled.g3[id="HeaderMenu__MenuWrapper-sc-14dkklk-0"]{content:"itjVmX,"}/*!sc*/
.kIlpOB{line-height:32px;min-width:96px;text-align:center;border-bottom:none;}/*!sc*/
.bNdHDE{line-height:32px;min-width:96px;text-align:center;border-bottom:2px solid #EB984E;}/*!sc*/
data-styled.g4[id="HeaderMenu__MenuItem-sc-14dkklk-1"]{content:"kIlpOB,bNdHDE,"}/*!sc*/
.dGCYZo{-webkit-text-decoration:none;text-decoration:none;color:#24292f;}/*!sc*/
data-styled.g5[id="HeaderMenu__Link-sc-14dkklk-2"]{content:"dGCYZo,"}/*!sc*/
.bmDBta{margin:0;padding:32px 16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;width:1280px;}/*!sc*/
data-styled.g6[id="PageWrapper__Wrapper-sc-859ve4-0"]{content:"bmDBta,"}/*!sc*/
.Kjbfq{width:256px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:column nowrap;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:768px){.Kjbfq{display:none;}}/*!sc*/
data-styled.g7[id="PageWrapper__SideBarWrapper-sc-859ve4-1"]{content:"Kjbfq,"}/*!sc*/
.ikqffP{-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:column nowrap;-ms-flex-flow:column nowrap;flex-flow:column nowrap;}/*!sc*/
data-styled.g9[id="PageWrapper__MainContentWrapper-sc-859ve4-3"]{content:"ikqffP,"}/*!sc*/
.jeBpnd{width:128px;height:128px;margin:32px 0 8px 0;}/*!sc*/
data-styled.g10[id="PageWrapper__StyledAvatar-sc-859ve4-4"]{content:"jeBpnd,"}/*!sc*/
.jIJyRi{margin-bottom:4px;font-size:1.6rem;}/*!sc*/
data-styled.g11[id="PageWrapper__Name-sc-859ve4-5"]{content:"jIJyRi,"}/*!sc*/
</style></head><body><div id="__next" data-reactroot=""><div class="PageWrapper__Wrapper-sc-859ve4-0 bmDBta"><div class="PageWrapper__SideBarWrapper-sc-859ve4-1 Kjbfq"><img class="Avatar__Img-sc-j2rhp9-0 cRaYml PageWrapper__StyledAvatar-sc-859ve4-4 jeBpnd" src="/avatar.jpeg"/><span class="PageWrapper__Name-sc-859ve4-5 jIJyRi">孙晓聪</span></div><div class="PageWrapper__MainContentWrapper-sc-859ve4-3 ikqffP"><menu class="HeaderMenu__MenuWrapper-sc-14dkklk-0 itjVmX"><li class="HeaderMenu__MenuItem-sc-14dkklk-1 kIlpOB"><a href="/" class="HeaderMenu__Link-sc-14dkklk-2 dGCYZo">最新</a></li><li selected="" class="HeaderMenu__MenuItem-sc-14dkklk-1 bNdHDE"><a href="/blogs" class="HeaderMenu__Link-sc-14dkklk-2 dGCYZo">博客</a></li><li class="HeaderMenu__MenuItem-sc-14dkklk-1 kIlpOB"><a href="/readings" class="HeaderMenu__Link-sc-14dkklk-2 dGCYZo">书评</a></li></menu><div class="PageWrapper__ContentWrapper-sc-859ve4-2 gUefAE"><ul><li><a href="/blogs/life/cycling/pick_first_cycle.md">life/cycling/pick_first_cycle.md</a></li><li><a href="/blogs/oj/leet_code/0001_two_sum.md">oj/leet_code/0001_two_sum.md</a></li><li><a href="/blogs/oj/leet_code/0002_add_two_numbers.md">oj/leet_code/0002_add_two_numbers.md</a></li><li><a href="/blogs/oj/leet_code/0003_longest_substring.md">oj/leet_code/0003_longest_substring.md</a></li><li><a href="/blogs/oj/leet_code/0004_median_of_two_sorted_arrays.md">oj/leet_code/0004_median_of_two_sorted_arrays.md</a></li><li><a href="/blogs/oj/leet_code/0005_longest_palindromic_substring.md">oj/leet_code/0005_longest_palindromic_substring.md</a></li><li><a href="/blogs/oj/leet_code/0019_remove_Nth_node_from_end_of_list.md">oj/leet_code/0019_remove_Nth_node_from_end_of_list.md</a></li><li><a href="/blogs/oj/leet_code/0020._valid_parentheses.md">oj/leet_code/0020._valid_parentheses.md</a></li><li><a href="/blogs/oj/leet_code/0021_merge_two_sorted_lists.md">oj/leet_code/0021_merge_two_sorted_lists.md</a></li><li><a href="/blogs/oj/leet_code/0031_next_permutation.md">oj/leet_code/0031_next_permutation.md</a></li><li><a href="/blogs/oj/leet_code/0035_search_insert_position.md">oj/leet_code/0035_search_insert_position.md</a></li><li><a href="/blogs/oj/leet_code/0046_permutations.md">oj/leet_code/0046_permutations.md</a></li><li><a href="/blogs/oj/leet_code/0053_maximum_subarray.md">oj/leet_code/0053_maximum_subarray.md</a></li><li><a href="/blogs/oj/leet_code/0062_unique_paths.md">oj/leet_code/0062_unique_paths.md</a></li><li><a href="/blogs/oj/leet_code/0070_climbing_stairs.md">oj/leet_code/0070_climbing_stairs.md</a></li><li><a href="/blogs/oj/leet_code/0088_merge_two_sorted_arrary.md">oj/leet_code/0088_merge_two_sorted_arrary.md</a></li><li><a href="/blogs/oj/leet_code/0094_binary_tree_inorder_traversal.md">oj/leet_code/0094_binary_tree_inorder_traversal.md</a></li><li><a href="/blogs/oj/leet_code/0102_binary_tree_level_order_traversal.md">oj/leet_code/0102_binary_tree_level_order_traversal.md</a></li><li><a href="/blogs/oj/leet_code/0104_maximum_depth_of_binary_tree.md">oj/leet_code/0104_maximum_depth_of_binary_tree.md</a></li><li><a href="/blogs/oj/leet_code/0112_path_sum.md">oj/leet_code/0112_path_sum.md</a></li><li><a href="/blogs/oj/leet_code/0113_path_sum_II.md">oj/leet_code/0113_path_sum_II.md</a></li><li><a href="/blogs/oj/leet_code/0116_populating_next_right_pointers_in_each_node.md">oj/leet_code/0116_populating_next_right_pointers_in_each_node.md</a></li><li><a href="/blogs/oj/leet_code/0121_best_time_to_buy_and_sell_stock.md">oj/leet_code/0121_best_time_to_buy_and_sell_stock.md</a></li><li><a href="/blogs/oj/leet_code/0129_sum_root_to_leaf_numbers.md">oj/leet_code/0129_sum_root_to_leaf_numbers.md</a></li><li><a href="/blogs/oj/leet_code/0146_LRU_cache.md">oj/leet_code/0146_LRU_cache.md</a></li><li><a href="/blogs/oj/leet_code/0160_intersection_of_two_linked_lists.md">oj/leet_code/0160_intersection_of_two_linked_lists.md</a></li><li><a href="/blogs/oj/leet_code/0165_compare_version_numbers.md">oj/leet_code/0165_compare_version_numbers.md</a></li><li><a href="/blogs/oj/leet_code/0167_two_sum_II.md">oj/leet_code/0167_two_sum_II.md</a></li><li><a href="/blogs/oj/leet_code/0189_rotate_array.md">oj/leet_code/0189_rotate_array.md</a></li><li><a href="/blogs/oj/leet_code/0206_reversed_linked_list.md">oj/leet_code/0206_reversed_linked_list.md</a></li><li><a href="/blogs/oj/leet_code/0209_minimum_size_subarray_sum.md">oj/leet_code/0209_minimum_size_subarray_sum.md</a></li><li><a href="/blogs/oj/leet_code/0215_kth_largest_element_in_an_array.md">oj/leet_code/0215_kth_largest_element_in_an_array.md</a></li><li><a href="/blogs/oj/leet_code/0226_invert_binary_tree.md">oj/leet_code/0226_invert_binary_tree.md</a></li><li><a href="/blogs/oj/leet_code/0236_lowest_common_ancestor_of_a_binary_tree.md">oj/leet_code/0236_lowest_common_ancestor_of_a_binary_tree.md</a></li><li><a href="/blogs/oj/leet_code/0278._first_bad_version.md">oj/leet_code/0278._first_bad_version.md</a></li><li><a href="/blogs/oj/leet_code/0283_move_zeroes.md">oj/leet_code/0283_move_zeroes.md</a></li><li><a href="/blogs/oj/leet_code/0300_longest_increasing_subsequence.md">oj/leet_code/0300_longest_increasing_subsequence.md</a></li><li><a href="/blogs/oj/leet_code/0344_reverse_string.md">oj/leet_code/0344_reverse_string.md</a></li><li><a href="/blogs/oj/leet_code/0349_intersection_of_two_arrays.md">oj/leet_code/0349_intersection_of_two_arrays.md</a></li><li><a href="/blogs/oj/leet_code/0415_add_strings.md">oj/leet_code/0415_add_strings.md</a></li><li><a href="/blogs/oj/leet_code/0429_nary_tree_level_order_traversal.md">oj/leet_code/0429_nary_tree_level_order_traversal.md</a></li><li><a href="/blogs/oj/leet_code/0468_validate_IP_address.md">oj/leet_code/0468_validate_IP_address.md</a></li><li><a href="/blogs/oj/leet_code/0509_fibonacci_number.md">oj/leet_code/0509_fibonacci_number.md</a></li><li><a href="/blogs/oj/leet_code/0542_01_matrix.md">oj/leet_code/0542_01_matrix.md</a></li><li><a href="/blogs/oj/leet_code/0557_reverse_words_in_a_string.md">oj/leet_code/0557_reverse_words_in_a_string.md</a></li><li><a href="/blogs/oj/leet_code/0567_permutation_in_string.md">oj/leet_code/0567_permutation_in_string.md</a></li><li><a href="/blogs/oj/leet_code/0617_merge_two_binary_trees.md">oj/leet_code/0617_merge_two_binary_trees.md</a></li><li><a href="/blogs/oj/leet_code/0695_max_area_of_island.md">oj/leet_code/0695_max_area_of_island.md</a></li><li><a href="/blogs/oj/leet_code/0704_binary_search.md">oj/leet_code/0704_binary_search.md</a></li><li><a href="/blogs/oj/leet_code/0718_maximum_length_of_repeated_subarray.md">oj/leet_code/0718_maximum_length_of_repeated_subarray.md</a></li><li><a href="/blogs/oj/leet_code/0733_flood_fill.md">oj/leet_code/0733_flood_fill.md</a></li><li><a href="/blogs/oj/leet_code/0876_middle_of_the_linked_list.md">oj/leet_code/0876_middle_of_the_linked_list.md</a></li><li><a href="/blogs/oj/leet_code/0977_squares_of_a_sorted_array.md">oj/leet_code/0977_squares_of_a_sorted_array.md</a></li><li><a href="/blogs/oj/leet_code/1047_remove_all_adjacent_duplicates_in_string.md">oj/leet_code/1047_remove_all_adjacent_duplicates_in_string.md</a></li><li><a href="/blogs/web_animation.md">web_animation.md</a></li></ul></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blogs":[{"name":"pick_first_cycle.md","categories":["life","cycling"],"content":"\n# 选自行车\n\n## 计划\n\n想买车这个想法由来已久，之前是一直骑摩拜，真的是磨屁股，还骑不快，想着是时候升级一下装备了，然后最近也打算来一个半程川藏线然后转到丽江。\n\n现在自行车品牌真的是五花八门的，不过当你仔细筛选一下的话其实就几个比较靠谱的：\n\n1. GIANT(捷安特)\n2. 美利达\n3. 喜德盛\n\n欧美不考虑（太贵），永久/凤凰不考虑（太老）\n\n最后在这三个品牌的里面筛选。\n\n大概查了一下，现在自行车主要分： 山地车，公路车，旅行车等\n\n山地车 -- 轮胎比较宽抓地力比较长，带减震（前叉锁死）。适合混合路面/山地路面\n公路车 -- 适合路况较好的公路行驶。\n旅行车 -- 一定程度考虑长途骑行的舒适度。\n\n然后 车子还分车架成分，烧钱的碳纤维和普通的铝合金\n\n考虑到自己平时比较作，然后又要骑路面情况比较复杂的川藏线，资金还有限。所以果断定位在了 山地车 -- 铝合金车架。\n\n## 网上筛选\n\n大概定位好车子后我就开始疯狂的筛选备选款式了。这些自行车厂商的网站一般都会有所有车子的详细资料有些还可以在线对比。\n\n最后初步赛选出来了两款比较合理的车：\n\n喜德盛的传奇系列：\n\n![逐日600](chasing600.png)\n\n捷安特的 ATX 系列：\n![ATX860](atx860.jpeg)\n\n## 实地选车\n\n实地选车大概经理了一周左右吧，刚开始就一直想去看喜德盛的车但是喜德盛的专卖店 9 点就关门了，然后我从公司带专卖店还得有一个多小时的车程（我还想着共享单车去），直接到时我又一次去了过后只能眼巴巴的盯着玻璃后面的自行车。后面选择了先去看捷安特的，我选择了一个离我住的地方没有多远的专卖店。到店后店主正在组装一台自行车，看着挺忙的，等了一会。师傅很热情的给我介绍了基本所有的车型，但我当时没有问我网上选好的，所以我第二天又过来了，直接问了 ATX777 然后他给我说 ATX860 是一样的听他详细给我介绍了一帆过后都打算买了，但是这个专卖店没有 M 号只有 S 号，很尴尬，本来想让店主去定的，但是他直接给我来了一句你骑 S 号也行。。。怎么能随便，所以果断换店了。\n\n## 后续\n\n后面果断买了捷安特的 XTC，估计是后面没有时间来更新这篇文章了。\n","meta":{"title":"Cycling","date":"Mon Sep 09 2019 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"essay","private":false}},{"name":"0001_two_sum.md","categories":["oj","leet_code"],"content":"\n# Two Sum\n\n## Descrption\n\n[original description](https://leetcode.com/problems/two-sum/)\n\n## Solutions\n\n### Brute Force\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  for (let i = 0; i \u003c nums.length - 1; i++) {\n    for (let j = i + 1; j \u003c nums.length; j++) {\n      if (nums[i] + nums[j] === target) {       // check every possible case\n        return [i, j];\n      }\n    }\n  }\n  return [-1, -1] // will never touch\n};\n```\n\n- Time Complexity: O(n^2)\n- Space Complexity: O(1)\n\n### Cache Diff by Map\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  const cache = {}\n  for (let i = 0; i \u003c nums.length; i++) {\n    const cachedIndex = cache[target - nums[i]];\n    if (cachedIndex !== undefined) {              // found cached diff, return directly\n      return [cachedIndex, i];        \n    }\n\n    cache[nums[i]] = i;                           // otherwise cache it for later use\n  }\n\n  return [-1, -1];\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n","meta":{"title":"Two Sum","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0002_add_two_numbers.md","categories":["oj","leet_code"],"content":"\n# Add Two Numbers\n\n## Description\n\n[original description](https://leetcode.com/problems/add-two-numbers/)\n\n## Solutions\n\n### Clear Version\n\nsimulate the calculation\n\n```javascript\nfunction ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  const head = new ListNode();\n  let current = head;\n  let carry = 0;\n\n  while (l1 \u0026\u0026 l2) {\n    const sum = l1.val + l2.val + carry;\n    const val = sum % 10;\n    carry = Math.floor(sum / 10);\n\n    current.next = new ListNode(val);\n    current = current.next;\n    l1 = l1.next;\n    l2 = l2.next;\n  }\n\n  while (l1) {\n    const sum = l1.val + carry;\n    const val = sum % 10;\n    carry = Math.floor(sum / 10);\n\n    current.next = new ListNode(val);\n    current = current.next;\n    l1 = l1.next;\n  }\n\n  while (l2) {\n    const sum = l2.val + carry;\n    const val = sum % 10;\n    carry = Math.floor(sum / 10);\n\n    current.next = new ListNode(val);\n    current = current.next;\n    l2 = l2.next;\n  }\n\n  if (carry) {\n    current.next = new ListNode(carry);\n  }\n\n  return head.next;\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n### Merge Calculation\n\n```javascript\nfunction ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  const head = new ListNode();\n  let current = head;\n  let carry = 0;\n\n  while (l1 || l2) {\n    const sum = (l1?.val ?? 0) + (l2?.val ?? 0) + carry;    // the new syntax\n    const val = sum % 10;\n    carry = Math.floor(sum / 10);\n\n    current.next = new ListNode(val);\n    current = current.next;\n    l1 = l1?.next;\n    l2 = l2?.next;\n  }\n\n  if (carry) {\n    current.next = new ListNode(carry);\n  }\n\n  return head.next;\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Add Two Numbers","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0003_longest_substring.md","categories":["oj","leet_code"],"content":"\n# Longest Substring Without Repeating Characters\n\n## Description\n\n[original description](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\n## Solutions\n\n### First Idea\n\none scaning\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let result = 0;\n\n  let cache = {};\n  let lengthCount = 0;\n  let start = 0;\n\n  for (let i = 0; i \u003c s.length; i++) {\n    const ch = s.charAt(i);\n    const index = cache[ch];\n\n    if (index != undefined) {\n      for (let j = start; j \u003c= index; j++) {\n        delete cache[s.charAt(j)];\n      }\n\n      lengthCount = lengthCount - (index - start + 1);\n      start = index + 1;\n    }\n\n    lengthCount++;\n    cache[ch] = i;\n    result = result \u003c lengthCount ? lengthCount : result;\n  }\n\n  return result;\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n### Sliding Window\n\nMy first solution for this problem is similar to Sliding Window, check [doc](https://www.code-recipe.com/post/longest-substring-without-repeating-characters) for details.\n\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n  let max = 0;\n  let cachedKeys = {};\n\n  let start = 0; // the sliding window\n  let end = 0;\n\n  for (; end \u003c s.length; end++) {\n    const cachedIndex = cachedKeys[s[end]];\n\n    if (cachedIndex !== undefined) {\n      const len = end - start;\n      max = max \u003c len ? len : max;\n\n      for (let j = start; j \u003c= cachedIndex; j++) {\n        delete cachedKeys[s.charAt(j)];\n      }\n\n      start = cachedIndex + 1;\n    }\n\n    cachedKeys[s.charAt(end)] = end;\n  }\n\n  return max \u003c end - start ? end - start : max;\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Longest Substring Without Repeating Characters","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0004_median_of_two_sorted_arrays.md","categories":["oj","leet_code"],"content":"\n# Median of Two Sorted Arrays\n\n## Descriptions\n\n[original description](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n  const len = nums1.length + nums2.length;\n  const max = len % 2 ? (len - 1) / 2 : len / 2;\n  let prev = null;\n  let pprev = null;\n\n  let cur1 = 0;\n  let cur2 = 0;\n\n  for (let i = 0; i \u003c= max; i++) {\n    pprev = prev;\n    prev =\n      (nums1[cur1] ?? Number.MAX_VALUE) \u003c (nums2[cur2] ?? Number.MAX_VALUE)\n        ? nums1[cur1++]\n        : nums2[cur2++];\n  }\n\n  return len % 2 ? prev : (pprev + prev) / 2;\n};\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Median of Two Sorted Arrays","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0005_longest_palindromic_substring.md","categories":["oj","leet_code"],"content":"\n# Longest Palindromic Substring\n\n## Description\n\n[doc](https://github.com/afatcoder/LeetcodeTop/blob/master/bytedance/frontend.md)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  let result = []\n\n  for (let i = 0; i \u003c s.length; i++) {\n    let j = i\n    while ((j = s.indexOf(s.charAt(i), j + 1)) \u003e 0) {\n      let curR = j\n\n      if (j \u003c= i) {\n        continue\n      }\n\n      let curL = i\n\n      while (curL++ \u003c curR--) {\n        if (s.charAt(curL) !== s.charAt(curR)) {\n          break\n        }\n      }\n\n      if (curL \u003e= curR) {\n        result.push(s.substring(i, j + 1))\n      }\n    }\n  }\n\n  return result.reduce(\n    (maxStr, cur) =\u003e (maxStr.length \u003c cur.length ? cur : maxStr),\n    s.charAt(0)\n  )\n}\n```\n\n- Time Complexity: O(n^3)\n- Space Complexity: O(n \\* n)\n\n### Refined Version\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  if (s.length \u003c 2) {\n    return s[0]\n  }\n\n  let start = 0\n  let end = 0\n\n  function expendForPalindromic(i, j) {\n    while (i \u003e= 0 \u0026\u0026 j \u003c s.length \u0026\u0026 s.charAt(i) === s.charAt(j)) {\n      i--\n      j++\n    }\n\n    if (end - start \u003c j - i - 1) {\n      start = i + 1\n      end = j\n    }\n  }\n\n  for (let i = 0; i \u003c s.length; i++) {\n    expendForPalindromic(i, i)\n    expendForPalindromic(i, i + 1)\n  }\n\n  return s.substring(start, end)\n}\n```\n\n- Time Complexity: O(n^2)\n- Space Complexity: O(1)\n","meta":{"title":"Longest Palindromic Substring","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0019_remove_Nth_node_from_end_of_list.md","categories":["oj","leet_code"],"content":"\n# Remove Nth Node From End of List\n\n## Description\n\n[doc](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function (head, n) {\n  let cur = head\n  let count = 0\n\n  while (cur) {\n    cur = cur.next\n    count++\n  }\n\n  let target = count - n\n  if (target === 0) {\n    return head.next\n  }\n\n  cur = head\n  for (let i = 1; i \u003c target; i++) {\n    cur = cur.next\n  }\n\n  cur.next = cur.next.next\n\n  return head\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Remove Nth Node From End of List","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0020._valid_parentheses.md","categories":["oj","leet_code"],"content":"\n# Valid Parentheses\n\n## Description\n\n[doc](https://leetcode.com/problems/valid-parentheses/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nconst validCloses = { ')': '(', '}': '{', ']': '[' }\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function (s) {\n  let stack = []\n\n  for (let i = 0; i \u003c s.length; i++) {\n    const ch = s.charAt(i)\n    const opening = validCloses[ch]\n\n    if (!opening) {\n      stack.push(ch)\n      continue\n    }\n\n    const top = stack.pop()\n    if (top !== opening) {\n      return false\n    }\n  }\n\n  return stack.length === 0\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Valid Parentheses","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0021_merge_two_sorted_lists.md","categories":["oj","leet_code"],"content":"\n# Merge Two Sorted Lists\n\n## Description\n\n[doc](https://leetcode.com/problems/merge-two-sorted-lists/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n  if (!list1 || !list2) {\n    return list1 || list2\n  }\n\n  let cur = (head = {})\n  while (list1 \u0026\u0026 list2) {\n    if (list1.val \u003c list2.val) {\n      cur.next = list1\n      list1 = list1.next\n    } else {\n      cur.next = list2\n      list2 = list2.next\n    }\n\n    cur = cur.next\n  }\n\n  cur.next = list1 ? list1 : list2\n  return head.next\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Merge Two Sorted Lists","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0031_next_permutation.md","categories":["oj","leet_code"],"content":"\n# Next Permutation\n\n## Description\n\n[doc](https://leetcode.com/problems/next-permutation/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nfunction sortSubArrayInPlace(start, nums) {\n  for (let i = start; i \u003c nums.length; i++) {\n    let minIdx = i\n    for (let j = i + 1; j \u003c nums.length; j++) {\n      if (nums[j] \u003c nums[minIdx]) {\n        minIdx = j\n      }\n    }\n    if (minIdx !== i) {\n      let tmp = nums[minIdx]\n      nums[minIdx] = nums[i]\n      nums[i] = tmp\n    }\n  }\n}\n\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function (nums) {\n  let idx = nums.length - 1\n  while (idx \u003e 0) {\n    if (nums[idx - 1] \u003c nums[idx]) {\n      break\n    }\n\n    idx--\n  }\n\n  const prev = idx - 1\n  if (prev \u003c 0) {\n    return sortSubArrayInPlace(idx, nums)\n  }\n\n  sortSubArrayInPlace(idx, nums)\n  while (idx \u003c nums.length) {\n    if (nums[idx] \u003e nums[prev]) {\n      break\n    }\n    idx++\n  }\n\n  const tmp = nums[idx]\n  nums[idx] = nums[prev]\n  nums[prev] = tmp\n  return nums\n}\n```\n","meta":{"title":"Next Permutation","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0035_search_insert_position.md","categories":["oj","leet_code"],"content":"\n# Search Insert Position\n\n## Descripition\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function (nums, target) {\n  let low = 0\n  let high = nums.length - 1\n\n  // only -\u003e\u003e [low v high] [low v, v high] -\u003e\u003e [low, high]\n  while (low \u003c high) {\n    const middle = low + Math.floor((high - low) / 2)\n    if (nums[middle] === target) {\n      return middle\n    }\n\n    nums[middle] \u003c target ? (low = middle + 1) : (high = middle - 1)\n  }\n\n  return target \u003e nums[low] ? low + 1 : low\n}\n```\n\n-- Time Complexity: O(logn)\n-- Space Complexity: O(1)\n","meta":{"title":"Search Insert Position","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0046_permutations.md","categories":["oj","leet_code"],"content":"\n# Permutations\n\n## Description\n\n[doc](https://leetcode.com/problems/permutations/)\n\n## Solutions\n\n### First idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function (nums) {\n  if (nums.length === 1) {\n    return [nums]\n  }\n\n  let result = []\n  for (let i = 0; i \u003c nums.length; i++) {\n    result = [\n      ...result,\n      ...permute([...nums.slice(0, i), ...nums.slice(i + 1)]).map((v) =\u003e [\n        nums[i],\n        ...v,\n      ]),\n    ]\n  }\n\n  return result\n}\n```\n","meta":{"title":"Permutations","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0053_maximum_subarray.md","categories":["oj","leet_code"],"content":"\n# Maximum Subarray\n\n## Description\n\n[doc](https://leetcode.com/problems/maximum-subarray/)\n\n## Solutions\n\n### Dynamic Programing\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  let sum = (max = nums[0])\n\n  for (let i = 1; i \u003c nums.length; i++) {\n    const sumWithCurrent = sum + nums[i]\n\n    sum = sumWithCurrent \u003c nums[i] ? nums[i] : sumWithCurrent\n    max = sum \u003e max ? sum : max\n  }\n\n  return max\n}\n```\n","meta":{"title":"Maximum Subarray","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0062_unique_paths.md","categories":["oj","leet_code"],"content":"\n# Unique Paths\n\n## Description\n\n[doc](https://leetcode.com/problems/unique-paths/)\n\n## Solutions\n\n### [Time Exceeded] First Idea\n\n```javascript\nconst DIRS = [\n  [1, 0],\n  [0, 1],\n]\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n  const [endX, endY] = [n - 1, m - 1]\n  let queue = [[0, 0]]\n  let pathCount = 0\n\n  while (queue.length) {\n    const [x, y] = queue.shift()\n\n    if (x === endX \u0026\u0026 y === endY) {\n      pathCount++\n      continue\n    }\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      const newX = x + _x\n      const newY = y + _y\n\n      if (newX \u003e endX || newY \u003e endY) {\n        return\n      }\n\n      queue.push([newX, newY])\n    })\n  }\n\n  return pathCount\n}\n```\n\n- Time Complexity: O(?)\n- Space Complexty: O(1)\n\n### [Time Exceeded] Recursive Version\n\n```javascript\nconst DIRS = [\n  [-1, 0],\n  [0, -1],\n]\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n  if (!(m - 1) \u0026\u0026 !(n - 1)) {\n    return 1\n  }\n\n  return DIRS.reduce((acc, [_x, _y]) =\u003e {\n    const newX = n + _x\n    const newY = m + _y\n\n    if (!newX || !newY) {\n      return acc\n    }\n\n    return acc + uniquePaths(newY, newX)\n  }, 0)\n}\n```\n\n### DP\n\n```javascript\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n  let matrics = Array(n)\n    .fill(0)\n    .map(() =\u003e Array(m).fill(0))\n\n  for (let y = 0; y \u003c m; y++) {\n    for (let x = 0; x \u003c n; x++) {\n      if (!x \u0026\u0026 !y) {\n        matrics[x][y] = 1\n        continue\n      }\n\n      const left = matrics[x - 1]?.[y] ?? 0\n      const top = matrics[x]?.[y - 1] ?? 0\n      matrics[x][y] = left + top\n    }\n  }\n\n  return matrics[n - 1][m - 1]\n}\n```\n\n- Time Complexity: O(m \\* n)\n- Space Complexity: O(m \\* n)\n","meta":{"title":"Unique Paths","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0070_climbing_stairs.md","categories":["oj","leet_code"],"content":"\n# Climbing Stairs\n\n## Description\n\n[doc](https://leetcode.com/problems/climbing-stairs/)\n\n## Solutions\n\n### Recursive Version\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  if (n \u003c 3) {\n    return n\n  }\n\n  return climbStairs(n - 1) + climbStairs(n - 2)\n}\n```\n\n### DP\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n  if (n \u003c 3) {\n    return n\n  }\n\n  let [prev, cur] = [1, 2]\n\n  for (let i = 3; i \u003c= n; i++) {\n    let next = prev + cur\n    prev = cur\n    cur = next\n  }\n\n  return cur\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Climbing Stairs","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0088_merge_two_sorted_arrary.md","categories":["oj","leet_code"],"content":"\n# Merge Two Sorted Array\n\n## Description\n\n[ref](https://leetcode.com/problems/merge-sorted-array/)\n\n## Solutions\n\n### Recursive Version\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n  let idx = m + n - 1\n  let idx1 = m - 1\n  let idx2 = n - 1\n\n  while (idx1 \u003e= 0 \u0026\u0026 idx2 \u003e= 0) {\n    nums1[idx--] = nums1[idx1] \u003e nums2[idx2] ? nums1[idx1--] : nums2[idx2--]\n  }\n\n  while (idx2 \u003e= 0) {\n    nums1[idx--] = nums2[idx2--]\n  }\n}\n```\n\n- Time Complexity: O(m + n)\n- Space Complexity: O(m + n)\n","meta":{"title":"Merge Two Sorted Array","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0094_binary_tree_inorder_traversal.md","categories":["oj","leet_code"],"content":"\n# Binary Tree Inorder Traversal\n\n## Description\n\n[doc](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  if (!root) {\n    return []\n  }\n\n  if (!root.left \u0026\u0026 !root.right) {\n    return [root.val]\n  }\n\n  return [\n    ...inorderTraversal(root.left),\n    root.val,\n    ...inorderTraversal(root.right),\n  ]\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n### Refined one\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n  if (!root) {\n    return []\n  }\n\n  return [\n    ...inorderTraversal(root.left),\n    root.val,\n    ...inorderTraversal(root.right),\n  ]\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Binary Tree Inorder Traversal","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0102_binary_tree_level_order_traversal.md","categories":["oj","leet_code"],"content":"\n# Binary Tree Level Order Traversal\n\n## Description\n\n[doc](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n  if (!root) {\n    return []\n  }\n\n  let result = []\n  let curLevel = []\n\n  let curQueue = [root]\n  let nextQueue = []\n\n  while (curQueue.length) {\n    const cur = curQueue.shift()\n\n    curLevel.push(cur.val)\n    cur.left \u0026\u0026 nextQueue.push(cur.left)\n    cur.right \u0026\u0026 nextQueue.push(cur.right)\n\n    if (!curQueue.length) {\n      curQueue = nextQueue\n      nextQueue = []\n      result.push(curLevel)\n      curLevel = []\n    }\n  }\n\n  return result\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Binary Tree Level Order Traversal","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0104_maximum_depth_of_binary_tree.md","categories":["oj","leet_code"],"content":"\n# Maximum Depth of Binary Tree\n\n## Description\n\n[doc](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n  if (root === null) {\n    return 0\n  }\n\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Maximum Depth of Binary Tree","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0112_path_sum.md","categories":["oj","leet_code"],"content":"\n# Path Sum\n\n## Description\n\n[doc](https://leetcode.com/problems/path-sum/)\n\n## Solutions\n\n### Recursive Version\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function (root, targetSum) {\n  if (!root) {\n    return false\n  }\n\n  const leftTarget = targetSum - root.val\n  if (!leftTarget \u0026\u0026 !root.left \u0026\u0026 !root.right) {\n    return true\n  }\n\n  return hasPathSum(root.left, leftTarget) || hasPathSum(root.right, leftTarget)\n}\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n```\n\n### DFS\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function (root, targetSum) {\n  if (!root) {\n    return false\n  }\n\n  const queue = [root]\n  while (queue.length) {\n    const cur = queue.shift()\n\n    const left = targetSum - cur.val\n    if (!left \u0026\u0026 !cur.left \u0026\u0026 !cur.right) {\n      return true\n    }\n\n    if (cur.left) {\n      cur.left.val += cur.val // try to make it immutable in prod\n      queue.push(cur.left)\n    }\n\n    if (cur.right) {\n      cur.right.val += cur.val\n      queue.push(cur.right)\n    }\n  }\n\n  return false\n}\n\n- Time Complexity: O(n)\n- Space Complexity: O(log(n)) ? maybe\n```\n","meta":{"title":"Path Sum","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0113_path_sum_II.md","categories":["oj","leet_code"],"content":"\n# Path Sum II\n\n## Description\n\n[doc](https://leetcode.com/problems/path-sum-ii/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nvar pathSum = function (root, targetSum) {\n  if (root === null) {\n    return []\n  }\n\n  const leftVal = targetSum - root.val\n  if (root.left === null \u0026\u0026 root.right === null) {\n    return leftVal ? [] : [[root.val]]\n  }\n\n  const left = pathSum(root.left, leftVal)\n  const right = pathSum(root.right, leftVal)\n\n  return [...left, ...right].map((v) =\u003e [root.val, ...v])\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n### BFS\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nvar pathSum = function (root, targetSum) {\n  if (root === null) {\n    return []\n  }\n\n  root.vals = [root.val]\n  let queue = [root]\n  let result = []\n\n  while (queue.length) {\n    const cur = queue.shift()\n\n    if (cur.left === null \u0026\u0026 cur.right === null \u0026\u0026 cur.val === targetSum) {\n      result.push(cur.vals)\n      continue\n    }\n\n    if (cur.left) {\n      cur.left.vals = [...cur.vals, cur.left.val]\n      cur.left.val += cur.val\n      queue.push(cur.left)\n    }\n\n    if (cur.right) {\n      cur.right.vals = [...cur.vals, cur.right.val]\n      cur.right.val += cur.val\n      queue.push(cur.right)\n    }\n  }\n\n  return result\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(nlogn)\n","meta":{"title":"Path Sum II","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0116_populating_next_right_pointers_in_each_node.md","categories":["oj","leet_code"],"content":"\n# Populating Next Right Pointers in Each Node\n\n## Description\n\n[doc](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * // Definition for a Node.\n * function Node(val, left, right, next) {\n *    this.val = val === undefined ? null : val;\n *    this.left = left === undefined ? null : left;\n *    this.right = right === undefined ? null : right;\n *    this.next = next === undefined ? null : next;\n * };\n */\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nvar connect = function (root) {\n  if (!root) {\n    return root\n  }\n\n  let queue = [root]\n  let nextQueue = []\n  let prev = null\n\n  while (queue.length) {\n    const tail = queue.shift()\n    tail.next = prev\n    prev = tail\n\n    tail.right \u0026\u0026 nextQueue.push(tail.right)\n    tail.left \u0026\u0026 nextQueue.push(tail.left)\n\n    if (queue.length === 0) {\n      queue = nextQueue\n      nextQueue = []\n      prev = null\n    }\n  }\n\n  return root\n}\n```\n","meta":{"title":"Populating Next Right Pointers in Each Node","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0121_best_time_to_buy_and_sell_stock.md","categories":["oj","leet_code"],"content":"\n# Best Time to Buy and Sell Stock\n\n## Dscription\n\n[doc](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n\n## Solutions\n\n### Fist Idea\n\n```javascript\n/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n  let min = 0\n  let maxProfit = 0\n\n  for (let i = 1; i \u003c prices.length; i++) {\n    let profit = prices[i] - prices[min]\n    maxProfit = Math.max(maxProfit, profit)\n    min = profit \u003c 0 ? i : min\n  }\n\n  return maxProfit\n}\n```\n","meta":{"title":"Best Time to Buy and Sell Stock","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0129_sum_root_to_leaf_numbers.md","categories":["oj","leet_code"],"content":"\n# Sum Root to Leaf Numbers\n\n## Description\n\n[ref](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\n\n## Solution\n\n### Recursive Solution\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n  function sum(node) {\n    if (!node) {\n      return []\n    }\n\n    if (!node.left \u0026\u0026 !node.right) {\n      return [`${node.val}`]\n    }\n\n    return [...sum(node.left), ...sum(node.right)].map((v) =\u003e node.val + v)\n  }\n\n  return sum(root).reduce((acc, cur) =\u003e acc + Number.parseInt(cur), 0)\n}\n```\n","meta":{"title":"Sum Root to Leaf Numbers","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0146_LRU_cache.md","categories":["oj","leet_code"],"content":"\n# LRU Cache\n\n## Description\n\n[doc](https://leetcode.com/problems/lru-cache/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.capacity = capacity\n\n  this.LRUCache = new Map()\n  this.low = 0\n  this.high = 0\n\n  this.cache = new Map()\n}\n\nLRUCache.prototype.getLRUKey = function () {\n  while (!this.LRUCache.has(this.low) \u0026\u0026 this.low \u003c this.high) {\n    this.low++\n  }\n\n  return this.LRUCache.get(this.low)\n}\n\nLRUCache.prototype.remove = function (key) {\n  const cur = this.cache.get(key)\n  if (cur) {\n    this.cache.delete(key)\n    this.LRUCache.delete(cur.cacheKey)\n  }\n\n  return cur\n}\n\nLRUCache.prototype.add = function (key, value) {\n  this.cache.set(key, { cacheKey: this.high, value })\n  this.LRUCache.set(this.high++, key)\n}\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  if (!this.cache.has(key)) {\n    return -1\n  }\n\n  const prev = this.remove(key)\n  this.add(key, prev.value)\n  return prev.value\n}\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  if (this.cache.has(key)) {\n    this.remove(key)\n  }\n\n  if (this.cache.size \u003e= this.capacity) {\n    const LRUKey = this.getLRUKey()\n    this.remove(LRUKey)\n  }\n\n  this.add(key, value)\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n","meta":{"title":"LRU Cache","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0160_intersection_of_two_linked_lists.md","categories":["oj","leet_code"],"content":"\n# Intersection of Two Linked Lists\n\n## Description\n\n[doc](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  let curA = headA\n\n  while (curA) {\n    let curB = headB\n\n    while (curB) {\n      if (Object.is(curA, curB)) {\n        return curA\n      }\n\n      curB = curB.next\n    }\n\n    curA = curA.next\n  }\n\n  return null\n}\n```\n\n- Time Complexity: O(n^2)\n- Space Complexity: O(1)\n\n### Hash Version\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  const nodesOfB = new WeakSet()\n  let cur = headB\n\n  while (cur) {\n    nodesOfB.add(cur)\n    cur = cur.next\n  }\n\n  cur = headA\n  while (cur) {\n    if (nodesOfB.has(cur)) {\n      return cur\n    }\n\n    cur = cur.next\n  }\n\n  return null\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Intersection of Two Linked Lists","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0165_compare_version_numbers.md","categories":["oj","leet_code"],"content":"\n# Compare Version Numbers\n\n## Description\n\n[doc](https://leetcode.com/problems/compare-version-numbers/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nconst trimZero = (acc, cur) =\u003e (!acc.length \u0026\u0026 cur === 0 ? acc : [cur, ...acc])\nconst toVersions = (v) =\u003e\n  v\n    .split('.')\n    .map((v) =\u003e parseInt(v))\n    .reduceRight(trimZero, [])\n\nconst compare = (a, b) =\u003e (a === b ? 0 : a \u003e b ? 1 : -1)\n\n/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nvar compareVersion = function (version1, version2) {\n  const vers1 = toVersions(version1)\n  const vers2 = toVersions(version2)\n  const min = vers1.length \u003c vers2.length ? vers1.length : vers2.length\n\n  for (let i = 0; i \u003c min; i++) {\n    const v1 = vers1[i]\n    const v2 = vers2[i]\n\n    if (v1 !== v2) {\n      return compare(v1, v2)\n    }\n  }\n\n  return compare(vers1.length, vers2.length)\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Compare Version Numbers","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0167_two_sum_II.md","categories":["oj","leet_code"],"content":"\n# Two Sum II - Input Array Is Sorted\n\n## Description\n\n[doc](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (numbers, target) {\n  let low = 0\n  let high = numbers.length - 1\n\n  while (low \u003c high) {\n    const sum = numbers[low] + numbers[high]\n\n    if (sum === target) {\n      return [low + 1, high + 1]\n    }\n\n    sum \u003c target ? low++ : high--\n  }\n\n  return -1\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Two Sum II - Input Array Is Sorted","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0189_rotate_array.md","categories":["oj","leet_code"],"content":"\n# Rotate Array\n\n## Description\n\n[doc](https://leetcode.com/study-plan/algorithm/?progress=d3ejkfm)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function (nums, k) {\n  const rotate = k % nums.length\n\n  const deleted = nums.splice(0, nums.length - rotate)\n  nums.push(...deleted)\n}\n```\n","meta":{"title":"Rotate Array","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0206_reversed_linked_list.md","categories":["oj","leet_code"],"content":"\n# Reverse Linked List\n\n## Description\n\n[doc](https://leetcode.com/problems/reverse-linked-list/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n  if (!head) {\n    return head\n  }\n\n  let prev = null\n  let cursor = head\n\n  while (cursor.next) {\n    let next = cursor.next\n    cursor.next = prev\n\n    prev = cursor\n    cursor = next\n  }\n\n  cursor.next = prev\n  return cursor\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n\n### Refined Version\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n  let prev = null\n  let cur = head\n\n  while (cur) {\n    let next = cur.next\n    cur.next = prev\n\n    prev = cur\n    cur = next\n  }\n\n  return prev\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Reverse Linked List","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0209_minimum_size_subarray_sum.md","categories":["oj","leet_code"],"content":"\n# Minimum Size Subarray Sum\n\n## Description\n\n[doc](https://leetcode.com/problems/minimum-size-subarray-sum/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function (target, nums) {\n  let [start, end] = [0, 0]\n  let sum = 0\n  let minLen = Number.MAX_SAFE_INTEGER\n\n  while (end \u003c nums.length) {\n    sum += nums[end++]\n\n    while (start \u003c end \u0026\u0026 sum \u003e= target) {\n      minLen = Math.min(minLen, end - start)\n      sum -= nums[start++]\n    }\n  }\n\n  return minLen === Number.MAX_SAFE_INTEGER ? 0 : minLen\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Minimum Size Subarray Sum","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0215_kth_largest_element_in_an_array.md","categories":["oj","leet_code"],"content":"\n# Kth Largest Element in an Array\n\n## Description\n\n[doc](https://leetcode.com/problems/kth-largest-element-in-an-array/)\n\n## Solutions\n\n### First idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n  // should not use the sort method directly\n  // since by default, sort will convert the value to string to compare between each other\n  // refer to [compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description)\n  return nums.sort((a, b) =\u003e a - b)[nums.length - k]\n}\n```\n\n- Time Complexity: O(n\\*logn) if using quick sort\n- Space Complexity: O(1)\n\n### Priority Queue\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n  const priorityQueue = []\n\n  for (const num of nums) {\n    const last = priorityQueue[k - 1]\n    if (last === undefined || num \u003e last) {\n      last === undefined\n        ? priorityQueue.push(num)\n        : (priorityQueue[k - 1] = num)\n\n      priorityQueue.sort((a, b) =\u003e b - a)\n    }\n  }\n\n  return priorityQueue[k - 1]\n}\n```\n\n\nTODO: add quick sort one\n### Quick Sort\n","meta":{"title":"Kth Largest Element in an Array","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0226_invert_binary_tree.md","categories":["oj","leet_code"],"content":"\n# Invert Binary Tree\n\n## Description\n\n[doc](https://leetcode.com/problems/invert-binary-tree/)\n\n## Solutions\n\n### Recursive Version\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n  if (!root) {\n    return root\n  }\n\n  let invertedLeft = invertTree(root.right)\n  root.right = invertTree(root.left)\n  root.left = invertedLeft\n\n  return root\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n\n### Queue Version\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n  if (!root) {\n    return root\n  }\n\n  let queue = [root]\n\n  while (queue.length) {\n    const cur = queue.shift()\n\n    cur.left \u0026\u0026 queue.push(cur.left)\n    cur.right \u0026\u0026 queue.push(cur.right)\n\n    let left = cur.left\n    cur.left = cur.right\n    cur.right = left\n  }\n\n  return root\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexty: O(n)\n","meta":{"title":"Invert Binary Tree","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0236_lowest_common_ancestor_of_a_binary_tree.md","categories":["oj","leet_code"],"content":"\n# Lowest Common Ancestor of a Binary Tree\n\n## Descrition\n\n[doc](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nfunction oneOf(p, q, ref) {\n  return ref.val === p.val || ref.val === q.val\n}\n\nfunction identical(p, q, left, right) {\n  return (\n    (left?.val === p.val \u0026\u0026 right?.val === q.val) ||\n    (left?.val === q.val \u0026\u0026 right?.val === p.val)\n  )\n}\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n  if (!root) {\n    return null\n  }\n\n  const left = lowestCommonAncestor(root.left, p, q)\n  const right = lowestCommonAncestor(root.right, p, q)\n\n  if (identical(p, q, left, right) || oneOf(p, q, root)) {\n    return root\n  }\n\n  return left !== null ? left : right\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n","meta":{"title":"Lowest Common Ancestor of a Binary Tree","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0278._first_bad_version.md","categories":["oj","leet_code"],"content":"\n# First Bad Version\n\n## Description\n\n[doc](https://leetcode.com/problems/first-bad-version/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for isBadVersion()\n *\n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function (isBadVersion) {\n  /**\n   * @param {integer} n Total versions\n   * @return {integer} The first bad version\n   */\n  return function (n) {\n    let low = 1\n    let high = n\n\n    while (low \u003c= high) {\n      const middle = low + Math.floor((high - low) / 2)\n      if (low === middle) {\n        return isBadVersion(low) ? low : low + 1\n      }\n\n      isBadVersion(middle) ? (high = middle) : (low = middle)\n    }\n\n    return -1\n  }\n}\n```\n\n- Time Complexity: O(logn)\n- Space Complexity: O(1)\n","meta":{"title":"First Bad Version","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0283_move_zeroes.md","categories":["oj","leet_code"],"content":"\n# Move Zeroes\n\n## Description\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n  let zeroIdx = -1\n\n  for (let i = 0; i \u003c nums.length; i++) {\n    if (nums[i] === 0 \u0026\u0026 zeroIdx \u003c 0) {\n      zeroIdx = i\n      continue\n    }\n\n    if (nums[i] !== 0 \u0026\u0026 zeroIdx \u003e= 0) {\n      nums[zeroIdx++] = nums[i]\n      nums[i] = 0\n    }\n  }\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n\n### Refined Version\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n  let zeroIdx = nums.indexOf(0)\n  if (zeroIdx \u003c 0) {\n    return\n  }\n\n  for (let i = zeroIdx + 1; i \u003c nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[zeroIdx++] = nums[i]\n      nums[i] = 0\n    }\n  }\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Move Zeroes","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0300_longest_increasing_subsequence.md","categories":["oj","leet_code"],"content":"\n# Longest Increasing Subsequence\n\n## Description\n\n[doc](https://leetcode.com/problems/longest-increasing-subsequence/)\n\n## Solutions\n\n### Brute Force\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function (nums) {\n  let maxTails = []\n  let max = 0\n\n  for (let i = 0; i \u003c nums.length; i++) {\n    let low = 0\n    let high = max\n\n    while (low \u003c high) {\n      const middle = Math.floor((low + hight) / 2)\n\n      if (maxTails[middle] \u003c nums[i]) {\n        low = middle + 1\n      } else {\n        high = middle\n      }\n    }\n  }\n\n  return max\n}\n```\n","meta":{"title":"Longest Increasing Subsequence","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0344_reverse_string.md","categories":["oj","leet_code"],"content":"\n# Reverse String\n\n## Description\n\n[doc](https://leetcode.com/problems/reverse-string/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function (s) {\n  let low = 0\n  let high = s.length - 1\n\n  while (low \u003c high) {\n    const tmp = s[low]\n    s[low++] = s[high]\n    s[high--] = tmp\n  }\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Reverse String","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0349_intersection_of_two_arrays.md","categories":["oj","leet_code"],"content":"\n# Intersection of Two Arrays\n\n## Description\n\n[doc](https://leetcode.com/problems/intersection-of-two-arrays/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n  const nums2Set = new Set(nums2)\n  return [...new Set(nums1)].filter((v) =\u003e nums2Set.has(v))\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Intersection of Two Arrays","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0415_add_strings.md","categories":["oj","leet_code"],"content":"\n# Add Strings\n\n## Dscription\n\n[doc](https://leetcode.com/problems/add-strings/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar addStrings = function (num1, num2) {\n  let k = (curry = 0)\n\n  let nums = []\n  let i = num1.length\n  let j = num2.length\n\n  while (i \u003e 0 || j \u003e 0) {\n    const sum = +(num1[--i] ?? 0) + +(num2[--j] ?? 0) + curry\n    curry = Math.floor(sum / 10)\n    nums[k++] = sum % 10\n  }\n\n  if (curry) {\n    nums[k] = curry\n  }\n\n  return nums.reverse().join('')\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Add Strings","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0429_nary_tree_level_order_traversal.md","categories":["oj","leet_code"],"content":"\n# N-ary Tree Level Order Traversal\n\n## Description\n\n[doc](https://leetcode.com/problems/n-ary-tree-level-order-traversal/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node|null} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n  if (!root) {\n    return []\n  }\n\n  let result = []\n  let curLevel = []\n\n  let curQueue = [root]\n  let nextQueue = []\n\n  while (curQueue.length) {\n    const cur = curQueue.shift()\n\n    curLevel.push(cur.val)\n    cur.children.forEach((v) =\u003e v \u0026\u0026 nextQueue.push(v))\n\n    if (!curQueue.length) {\n      curQueue = nextQueue\n      result.push(curLevel)\n      curLevel = []\n      nextQueue = []\n    }\n  }\n\n  return result\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"N-ary Tree Level Order Traversal","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0468_validate_IP_address.md","categories":["oj","leet_code"],"content":"\n# Validate IP Address\n\n## Description\n\n[doc](https://leetcode.com/problems/validate-ip-address/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nfunction isIPv4(ip) {\n  const digits = ip.split('.')\n  if (digits.length !== 4) {\n    return false\n  }\n\n  if (digits.some((v) =\u003e v.length \u003c 1 || (v.length \u003e 1 \u0026\u0026 v[0] === '0'))) {\n    return false\n  }\n\n  if (digits.some((v) =\u003e !/^[\\d]*$/.test(v))) {\n    return false\n  }\n\n  if (\n    digits.map((v) =\u003e parseInt(v)).some((v) =\u003e isNaN(v) || v \u003c 0 || v \u003e 255)\n  ) {\n    return false\n  }\n\n  return true\n}\n\nfunction isIPv6(ip) {\n  const digits = ip.split(':')\n  if (digits.length !== 8) {\n    return false\n  }\n\n  if (digits.some((v) =\u003e v.length \u003c 1 || v.length \u003e 4)) {\n    return false\n  }\n\n  if (digits.some((v) =\u003e !/^[\\da-fA-F]*$/.test(v))) {\n    return false\n  }\n\n  if (digits.some((v) =\u003e isNaN(parseInt(v, 16)))) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} queryIP\n * @return {string}\n */\nvar validIPAddress = function (queryIP) {\n  if (isIPv4(queryIP)) {\n    return 'IPv4'\n  }\n\n  if (isIPv6(queryIP)) {\n    return 'IPv6'\n  }\n\n  return 'Neither'\n}\n```\n","meta":{"title":"Validate IP Address","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0509_fibonacci_number.md","categories":["oj","leet_code"],"content":"\n# Fibonacci Number\n\n## Description\n\n[doc](https://leetcode.com/problems/fibonacci-number/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function (n) {\n  if (n \u003c 2) {\n    return n\n  }\n\n  let pprev = 0\n  let prev = 1\n  let cur\n\n  for (let i = 2; i \u003c= n; i++) {\n    cur = pprev + prev\n    pprev = prev\n    prev = cur\n  }\n\n  return cur\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n\n### Refined for Time\n\n```javascript\nconst cached = []\n/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function (n) {\n  if (n \u003c 2) {\n    return n\n  }\n\n  let pprev = 0\n  let prev = 1\n\n  for (let i = 2; i \u003c= n; i++) {\n    cached[i] = pprev + prev\n    pprev = prev\n    prev = cached[i]\n  }\n\n  return cached[n]\n}\n```\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n","meta":{"title":"Fibonacci Number","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0542_01_matrix.md","categories":["oj","leet_code"],"content":"\n# 01 Matrix\n\n## Description\n\n[doc](https://leetcode.com/problems/01-matrix/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nconst DIRS = [\n  [0, 1],\n  [-1, 0],\n  [0, -1],\n  [1, 0],\n]\n\nfunction searchNearestZero(mat, point) {\n  const mark = Array(mat.length)\n    .fill()\n    .map((_, i) =\u003e Array(mat[i].length))\n\n  let queue = [point]\n  mark[point[0]][point[1]] = 0\n\n  while (queue.length) {\n    const [x, y] = queue.shift()\n\n    if (mat[x][y] === 0) {\n      return mark[x][y]\n    }\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      const newX = x + _x\n      const newY = y + _y\n\n      if (mat[newX]?.[newY] == null || mark[newX][newY] != null) {\n        return\n      }\n\n      mark[newX][newY] = mark[x][y] + 1\n      queue.push([newX, newY])\n    })\n  }\n}\n\n/**\n * @param {number[][]} mat\n * @return {number[][]}\n */\nvar updateMatrix = function (mat) {\n  return mat.map((v, x) =\u003e v.map((sv, y) =\u003e (sv ? searchNearestZero(mat, [x, y]) : sv)))\n}\n```\n","meta":{"title":"01 Matrix","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0557_reverse_words_in_a_string.md","categories":["oj","leet_code"],"content":"\n# Reverse Words in a String III\n\n## Description\n\n[doc](https://leetcode.com/problems/reverse-words-in-a-string-iii/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function (s) {\n  return s\n    .split(' ')\n    .map((word) =\u003e word.split('').reverse().join(''))\n    .join(' ')\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(n)\n\n### Manual way\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function (s) {\n  let result = []\n  let i = 0\n  let cur = 0\n\n  while (cur \u003c s.length) {\n    while (s.charAt(cur) !== ' ' \u0026\u0026 cur \u003c s.length) {\n      cur++\n    }\n\n    let end = s.charAt(cur) === ' ' ? cur - 1 : cur\n    let rightCur = end\n    while (i \u003c= end) {\n      result[i++] = s.charAt(rightCur--)\n    }\n\n    if (s.charAt(cur) === ' ') {\n      result[i++] = s.charAt(cur)\n    }\n    cur++\n  }\n\n  return result.join('')\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(n)\n","meta":{"title":"Reverse Words in a String III","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0567_permutation_in_string.md","categories":["oj","leet_code"],"content":"\n# Permutation in String\n\n## Description\n\n[doc](https://leetcode.com/problems/permutation-in-string/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar checkInclusion = function (s1, s2) {\n  let map = new Map()\n  const reset = () =\u003e map.forEach(({ count, cur }, k) =\u003e map.set(k, { count, cur: 0 }))\n\n  for (let i = 0; i \u003c s1.length; i++) {\n    const ch = s1.charAt(i)\n    map.has(ch) ? map.set(ch, { count: map.get(ch).count + 1, cur: 0 }) : map.set(ch, { count: 1, cur: 0 })\n  }\n\n  for (let i = 0; i \u003c= s2.length - s1.length; i++) {\n    reset()\n    for (let j = 0; j \u003c s1.length; j++) {\n      const ch = s2.charAt(j + i)\n      if (!map.has(ch)) {\n        break\n      }\n\n      const { count, cur } = map.get(ch)\n      if (cur \u003e= count) {\n        break\n      }\n\n      map.set(ch, { count, cur: cur + 1 })\n\n      if (j === s1.length - 1) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n```\n\n-- Time Complexiy: O(n^2)\n-- Space Complexiy: O(n)\n### Refine Performance TODO:\n","meta":{"title":"Permutation in String","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0617_merge_two_binary_trees.md","categories":["oj","leet_code"],"content":"\n# Merge Two Binary Trees\n\n## Description\n\n[doc](https://leetcode.com/problems/merge-two-binary-trees/)\n\n## Solutions\n\n### DFS\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {TreeNode}\n */\nvar mergeTrees = function (root1, root2) {\n  if (!root1 || !root2) {\n    return root1 || root2\n  }\n\n  root1.left = mergeTrees(root1.left, root2.left)\n  root1.right = mergeTrees(root1.right, root2.right)\n\n  root1.val += root2.val\n\n  return root1\n}\n```\n","meta":{"title":"Merge Two Binary Trees","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0695_max_area_of_island.md","categories":["oj","leet_code"],"content":"\n# Max Area of Island\n\n## Description\n\n[doc](https://leetcode.com/problems/max-area-of-island/)\n\n## Solutions\n\n### BFS\n\n```javascript\nconst DIRS = [\n  [0, 1],\n  [-1, 0],\n  [0, -1],\n  [1, 0],\n] // top, right, bottom, left\n\nconst search = (grid, i, j) =\u003e {\n  let queue = [[i, j]]\n  let max = 1\n  grid[i][j] = 0\n\n  while (queue.length) {\n    const [x, y] = queue.shift()\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      let newX = x + _x\n      let newY = y + _y\n      if (grid[newX] \u0026\u0026 grid[newX][newY]) {\n        grid[newX][newY] = 0\n        max += 1\n        queue.push([newX, newY])\n      }\n    })\n  }\n\n  return max\n}\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function (grid) {\n  let max = 0\n  for (let i = 0; i \u003c grid.length; i++) {\n    for (let j = 0; j \u003c grid[i].length; j++) {\n      if (grid[i][j]) {\n        max = Math.max(search(grid, i, j), max)\n      }\n    }\n  }\n\n  return max\n}\n```\n\n### DFS\n\n```javascript\nconst DIRS = [\n  [0, 1],\n  [-1, 0],\n  [0, -1],\n  [1, 0],\n] // top, right, bottom, left\n\nconst search = (grid, i, j) =\u003e {\n  let stack = [[i, j]]\n  grid[i][j] = 0\n\n  let count = 1\n\n  while (stack.length) {\n    const [x, y] = stack.pop()\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      let newX = x + _x\n      let newY = y + _y\n      if (grid[newX] \u0026\u0026 grid[newX][newY]) {\n        grid[newX][newY] = 0\n        count += 1\n        stack.push([newX, newY])\n      }\n    })\n  }\n\n  return count\n}\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function (grid) {\n  let max = 0\n  for (let i = 0; i \u003c grid.length; i++) {\n    for (let j = 0; j \u003c grid[i].length; j++) {\n      if (grid[i][j]) {\n        max = Math.max(search(grid, i, j), max)\n      }\n    }\n  }\n\n  return max\n}\n```\n","meta":{"title":"Max Area of Island","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0704_binary_search.md","categories":["oj","leet_code"],"content":"\n# Binary Search\n\n## Description\n\n[doc](https://leetcode.com/problems/binary-search/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  let low = 0\n  let high = nums.length - 1\n\n  while (low \u003c= high) {\n    const middle = low + Math.floor((high - low) / 2)\n    const middleValue = nums[middle]\n\n    if (middleValue === target) {\n      return middle\n    }\n\n    middleValue \u003c target ? (low = middle + 1) : (high = middle - 1)\n  }\n\n  return -1\n}\n```\n\n- Time Complexity: O(logn)\n- Space Complexity: O(1)\n","meta":{"title":"Binary Search","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0718_maximum_length_of_repeated_subarray.md","categories":["oj","leet_code"],"content":"\n# Maximum Length of Repeated Subarray\n\n## Description\n\n[doc](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findLength = function (nums1, nums2) {\n  let max = 0\n\n  for (let i = 0; i \u003c nums1.length; i++) {\n    const cur = nums1[i]\n\n    for (let j = 0; j \u003c nums2.length; j++) {\n      const other = nums2[j]\n\n      if (other === cur) {\n        let k = 1\n        while (k + i \u003c nums1.length \u0026\u0026 k + j \u003c nums2.length) {\n          if (nums1[i + k] !== nums2[j + k]) {\n            break\n          }\n          k++\n        }\n        max = Math.max(max, k)\n      }\n    }\n  }\n\n  return max\n}\n```\n\n- Time Complexity: O(n^3)\n- Space Complexity: O(1)\n\n### TODO: we need a better solution for this\n","meta":{"title":"Maximum Length of Repeated Subarray","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0733_flood_fill.md","categories":["oj","leet_code"],"content":"\n# Flood Fill\n\n## Description\n\n[doc](https://leetcode.com/problems/flood-fill/)\n\n## Solutions\n\n### BFS\n\n```javascript\nconst DIRS = [\n  [0, 1],\n  [1, 0],\n  [0, -1],\n  [-1, 0],\n]\n\n/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\nvar floodFill = function (image, sr, sc, newColor) {\n  let queue = [[sr, sc]]\n  let visited = Array(image.length)\n    .fill()\n    .map(() =\u003e [])\n  const color = image[sr][sc]\n  visited[sr][sc] = true\n  image[sr][sc] = newColor\n\n  while (queue.length) {\n    const [x, y] = queue.shift()\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      const [newX, newY] = [x + _x, y + _y]\n\n      if (image[newX]?.[newY] === color \u0026\u0026 !visited[newX]?.[newY]) {\n        image[newX][newY] = newColor\n        visited[newX][newY] = true\n        queue.push([newX, newY])\n      }\n    })\n  }\n\n  return image\n}\n```\n\n### DFS\n\n```javascript\nconst DIRS = [\n  [0, 1],\n  [1, 0],\n  [0, -1],\n  [-1, 0],\n]\n\n/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\nvar floodFill = function (image, sr, sc, newColor) {\n  let stack = [[sr, sc]]\n  let visited = Array(image.length)\n    .fill()\n    .map(() =\u003e [])\n\n  const color = image[sr][sc]\n  image[sr][sc] = newColor\n\n  while (stack.length) {\n    const [x, y] = stack.pop()\n\n    DIRS.forEach(([_x, _y]) =\u003e {\n      const [newX, newY] = [x + _x, y + _y]\n\n      if (image[newX]?.[newY] === color \u0026\u0026 !visited[newX]?.[newY]) {\n        image[newX][newY] = newColor\n        visited[newX][newY] = true\n        stack.push([newX, newY])\n      }\n    })\n  }\n\n  return image\n}\n```\n","meta":{"title":"Flood Fill","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0876_middle_of_the_linked_list.md","categories":["oj","leet_code"],"content":"\n# Middle of the Linked List\n\n## Description\n\n[doc](https://leetcode.com/problems/middle-of-the-linked-list/)\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let count = 0\n  let cur = head\n\n  while (cur !== null) {\n    count++\n    cur = cur.next\n  }\n\n  let middle = Math.floor(count / 2)\n  cur = head\n  while (middle \u003e 0) {\n    cur = cur.next\n    middle--\n  }\n\n  return cur\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n\n### Two Pointers\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head)\n\n  while (fast) {\n    fast = fast.next\n    if (!fast) {\n      break\n    }\n\n    fast = fast.next\n    slow = slow.next\n  }\n\n  return slow\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n","meta":{"title":"Middle of the Linked List","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"0977_squares_of_a_sorted_array.md","categories":["oj","leet_code"],"content":"\n# Squares of a Sorted Array\n\n## Description\n\n## Solutions\n\n### First Idea\n\n```javascript\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function (nums) {\n  let right = 0\n  while (nums[right] \u003c 0) {\n    right++\n  }\n\n  for (let i = 0; i \u003c nums.length; i++) {\n    nums[i] = nums[i] ** 2\n  }\n\n  let result = Array(nums.length)\n  let cur = 0\n  let left = right - 1\n\n  while (left \u003e= 0 \u0026\u0026 right \u003c nums.length) {\n    result[cur++] = nums[left] \u003c nums[right] ? nums[left--] : nums[right++]\n  }\n\n  while (left \u003e= 0) {\n    result[cur++] = nums[left--]\n  }\n\n  while (right \u003c nums.length) {\n    result[cur++] = nums[right++]\n  }\n\n  return result\n}\n```\n\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\n\n## Notes\n\n```javascript\nfunction foo() {\n  let nums = [-1, -2]\n  let i = 0\n\n  // avoid using i++ in while loop for expression since it will increase unexcepted\n  while (nums[i++] \u003c 0) {}\n  return i\n}\n// result to 3\n\nfunction foo() {\n  let nums = [-1, -2]\n  let i = 0\n\n  // use this instead\n  while (nums[i] \u003c 0) {\n    i++\n  }\n  return i\n}\n```\n","meta":{"title":"Squares of a Sorted Array","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"1047_remove_all_adjacent_duplicates_in_string.md","categories":["oj","leet_code"],"content":"\n# Remove All Adjacent Duplicates In String\n\n## Description\n\n[doc](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)\n\n## Solutions\n\n### First Idea\n\n```javascript\nfunction indexOfDuplicated(str) {\n  let prev = 0\n  for (let i = 1; i \u003c str.length; i++) {\n    if (str.charAt(prev) === str.charAt(i)) {\n      return prev\n    }\n\n    prev = i\n  }\n\n  return -1\n}\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar removeDuplicates = function (s) {\n  let cur = s\n  let i = -1\n\n  while ((i = indexOfDuplicated(cur)) \u003e= 0) {\n    cur = cur.replace(`${cur.charAt(i)}${cur.charAt(i)}`, '')\n  }\n\n  return cur\n}\n```\n\n-- Time Complexity: O(n^2)\n-- Space Complexity: O(n)\n\n### Refined Version\n\n```javascript\nfunction findDuplicatedChars(start, s) {\n  let prev = start\n  for (let i = start + 1; i \u003c s.length; i++) {\n    if (s.charAt(prev) === s.charAt(i)) {\n      return prev\n    }\n\n    prev = i\n  }\n\n  return -1\n}\n\nfunction findRemovalRanges(start, s) {\n  let left = start\n  let right = start + 1\n\n  while (left \u003e= 0 \u0026\u0026 right \u003c s.length \u0026\u0026 s.charAt(left) === s.charAt(right)) {\n    left--\n    right++\n  }\n\n  return [left, right]\n}\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar removeDuplicates = function (s) {\n  let removals = []\n  let index = 0\n\n  while ((index = findDuplicatedChars(index, s)) \u003e= 0) {\n    removals.push(findRemovalRanges(index, s))\n  }\n\n  let result = []\n\n  for (let i = 0; i \u003c s.length; i++) {\n    if (!removals.some(([s, e]) =\u003e i \u003e= s \u0026\u0026 i \u003c= e)) {\n      result.push(s.charAt(i))\n    }\n  }\n\n  return result.join('')\n}\n```\n","meta":{"title":"Remove All Adjacent Duplicates In String","date":"Tue Feb 22 2022 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"oj","private":false}},{"name":"web_animation.md","categories":[],"content":"\n# Web Animation\n\nAnimations are a huge part of making compelling web applications and sites.\n\n## How to implement\n\n- CSS Transition \u0026 CSS Animation\n- Web Animation API\n- requestAnimationFrame\n\n### CSS Transition \u0026 CSS Animation\n\n#### CSS Transition\n\nCreate gradual transitions between the values of specific CSS properties.\n\n- [Demo Link](../../../src/web/animation/demo/index.html)\n\n- [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)\n\n##### Concepts\n\nCSS transitions let you decide\n\n- which properties to animate\n  by listing them explicitly\n\n- when the animation will start\n  by setting a delay (seconds)\n\n- how long the transition will last\n  by setting a duration\n\n- how the transition will run\n  by defining a timing function\n\n###### Choose properties to animate\n\nSpecifies the name or names of the CSS properties to which transitions should be applied.\n\n- Using `transition-property`\n\n```css\n.swa-flight {\n  transition-property: margin-left, margin-bottom;\n}\n```\n\n- Using `transition` as shorthand\n\n```css\n.swa-flight {\n  transition: margin-left, margin-bottom;\n}\n```\n\n\u003e if just declare the property, changes to the properties occur as usual.\n\n[List of properties can be animated](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)\n\nUsing CSS transform property\nThe transform CSS property lets you rotate, scale, skew, or translate an element. It modifies the coordinate space of the CSS visual formatting model.\n[MDN transform doc](https://www.quackit.com/css/functions/css_matrix_function.cfm)\n\n###### Set the animation duration\n\nSpecifies the duration over which transitions should occur.\n\n- Using `transition-duration`\n\n```css\n.swa-flight {\n  transition-property: mrigin-left, margin-bottom;\n  transition-duration: 8s, 4s;\n}\n```\n\n- Using `transition` as shorthand\n\n```css\n.swa-flight {\n  transition: width 8s, height 4s;\n}\n```\n\n###### Set up a timing-function\n\nSpecifies a function to define how intermediate values for properties are computed.\n\n- Using `transition-timing-function`\n\n```css\n.swa-flight {\n  transition-property: margin-left, margin-bottom;\n  transition-duration: 8s, 4s;\n  transition-timing-function: cubic-bezier(0.51, 0.18, 0.79, 0.53), cubic-bezier(0.7, 0.21, 1, 1);\n}\n```\n\n- Using `transition` as shorthand\n\n```css\n.swa-flight {\n  transition: margin-left 8s cubic-bezier(0.51, 0.18, 0.79, 0.53), margin-bottom\n      4s cubic-bezier(0.7, 0.21, 1, 1);\n}\n```\n\n[Easing function list](https://easings.net/)\n\n[cubic-bezier](http://cubic-bezier.com)\n\n###### Set a deply\n\nDefines how long to wait between the time a property is changed and the transition actually begins.\n\n- Using `transition-delay`\n\n```css\n.swa-flight {\n  transition-property: margin-left, margin-bottom;\n  transition-duration: 8s, 4s;\n  transition-timing-function: cubic-bezier(0.51, 0.18, 0.79, 0.53), cubic-bezier(0.7, 0.21, 1, 1);\n  transition-delay: 0s, 4s;\n}\n```\n\n- Using `transition` as shorthand\n\n```css\n.swa-flight {\n  transition: margin-left 8s cubic-bezier(0.51, 0.18, 0.79, 0.53), margin-bottom\n      4s cubic-bezier(0.7, 0.21, 1, 1) 4s;\n}\n```\n\n#### CSS Animation\n\nAnimations consist of two components, a style describing the CSS animation and a set of keyframes that indicate the start and end states of the animation’s style, as well as possible intermediate waypoints.\n\n###### Describing the animation\n\nBelow properties can be shorted as `animation` property.\n\n- `animation-name`\n- `animation-duration`\n- `animation-timing-function`\n- `animation-delay`\n- `animation-iteration-count`\n- `animation-direction`\n- `animation-fill-mode`\n- `animation-play-state`\n\n###### Describing the animation's style\n\nThe `@keyframes` CSS at-rule controls the intermediate steps in a CSS animation sequence\n\n[MDN Doc](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes)\n\n###### events\n\n`animationiteration`, `animationend`, `animationstart`\n\n[MDN Doc](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)\n\n### Web Animation API\n\nThe Web Animations API lets us construct animations and control their playback with JavaScript.\n\n#### Concepts\n\n- Timing\n- Animation\n- Animation Effect\n\n[MDN Doc](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Web_Animations_API_Concepts)\n\n##### Timing options\n\nIncluding duratiion, fill ... etc\n\n##### Animation Effect\n\nIt's a bundle of information including at the bare minimum a set of keys and the duration they need to be animated over.\n\n##### Animation\n\nUse the Animation Object’s methods to play, pause, seek, and control the animation’s playback direction and speed.\n\n```javascript\nconst drinking = document\n  .getElementById('liquid')\n  .animate([{ height: '100%' }, { height: '0' }], {\n    fill: 'forwards',\n    duration: 2000,\n  })\ndrinking.pause()\n```\n\n### requestAnimationFrame\n\ntells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.\n\n#### Syntax\n\n`window.requestAnimationFrame(callback);`\n","meta":{"title":"Web Animation","date":"Tue Aug 28 2018 00:00:00 GMT+0000 (Coordinated Universal Time)","tags":"essay","private":false}}]},"__N_SSG":true},"page":"/blogs","query":{},"buildId":"hTW_bqqKBeJGxFspWEgyj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>